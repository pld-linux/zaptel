diff -burN zaptel-1.4.5.1.orig/Makefile zaptel-1.4.5.1/Makefile
--- zaptel-1.4.5.1.orig/Makefile	2007-12-04 09:47:55.000000000 +0100
+++ zaptel-1.4.5.1/Makefile	2007-12-04 10:02:46.000000000 +0100
@@ -248,7 +248,7 @@
 
 UTILSO		= $(UTILS:%=%.o)
 
-BINS:=fxotune fxstest sethdlc-new ztcfg ztdiag ztmonitor ztspeed zttest zttool
+BINS:=fxotune fxstest sethdlc-new ztcfg ztdiag ztmonitor ztspeed zttest zttool ztpty
 BINS:=$(filter-out $(MENUSELECT_UTILS),$(BINS))
 MAN_PAGES:=$(wildcard $(BINS:%=doc/%.8))
 
@@ -332,6 +332,9 @@
 
 ztmonitor.o: ztmonitor.c zaptel.h
 
+ztpty.o: ztpty.c
+ztpty: ztpty.o
+
 ztspeed: CFLAGS=
 ztspeed.o: CFLAGS=
 zttool: LDLIBS+=$(NEWT_LIB)
diff -burN zaptel-1.4.5.1.orig/zaptel-base.c zaptel-1.4.5.1/zaptel-base.c
--- zaptel-1.4.5.1.orig/zaptel-base.c	2007-12-04 09:47:55.000000000 +0100
+++ zaptel-1.4.5.1/zaptel-base.c	2007-12-04 10:04:21.000000000 +0100
@@ -138,6 +138,7 @@
 EXPORT_SYMBOL(zt_qevent_lock);
 EXPORT_SYMBOL(zt_hooksig);
 EXPORT_SYMBOL(zt_alarm_notify);
+EXPORT_SYMBOL(zt_alarm_notify_no_master_change);
 EXPORT_SYMBOL(zt_set_dynamic_ioctl);
 EXPORT_SYMBOL(zt_ec_chunk);
 EXPORT_SYMBOL(zt_ec_span);
@@ -595,6 +596,10 @@
 		len += sprintf(page + len, "\tIRQ misses: %d\n", spans[span]->irqmisses);
 	len += sprintf(page + len, "\n");
 
+	if (spans[span]->proc_read) {
+		len += spans[span]->proc_read(spans[span], page + len);
+	}
+
 
         for (x=1;x<ZT_MAX_CHANNELS;x++) {	
 		if (chans[x]) {
@@ -2880,6 +2885,30 @@
 	}
 }
 
+void zt_alarm_notify_no_master_change(struct zt_span *span)
+{
+	int j;
+	int x;
+
+	span->alarms &= ~ZT_ALARM_LOOPBACK;
+	/* Determine maint status */
+	if (span->maintstat || span->mainttimer)
+		span->alarms |= ZT_ALARM_LOOPBACK;
+	/* DON'T CHANGE THIS AGAIN. THIS WAS DONE FOR A REASON.
+ 	   The expression (a != b) does *NOT* do the same thing
+	   as ((!a) != (!b)) */
+	/* if change in general state */
+	if ((!span->alarms) != (!span->lastalarms)) {
+		if (span->alarms)
+			j = ZT_EVENT_ALARM;
+		else
+			j = ZT_EVENT_NOALARM;
+		span->lastalarms = span->alarms;
+		for (x=0;x < span->channels;x++)
+			zt_qevent_lock(&span->chans[x], j);
+	}
+}
+
 #define VALID_SPAN(j) do { \
 	if ((j >= ZT_MAX_SPANS) || (j < 1)) \
 		return -EINVAL; \
@@ -5242,11 +5271,40 @@
 					*(txb++) = fasthdlc_tx_run_nocheck(&ms->txhdlc);
 				}
 				bytes -= left;
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+			} else if (ms->flags & ZT_FLAG_BRIDCHAN) {
+			    /*
+			     * Let's get this right, we want to transmit complete frames only.
+			     * The card driver will do the dirty HDLC work for us.
+			     * txb (transmit buffer) is supposed to be big enough to store one frame
+			     * we will make this as big as the D fifo (1KB or 2KB)
+			     */
+
+			    /* there are 'left' bytes in the user buffer left to transmit */
+			    left = ms->writen[ms->outwritebuf] - ms->writeidx[ms->outwritebuf] - 2;
+			    if (left > ms->maxbytes2transmit) {
+				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], ms->maxbytes2transmit);
+				ms->writeidx[ms->outwritebuf] += ms->maxbytes2transmit;
+				txb += ms->maxbytes2transmit;
+				ms->bytes2transmit = ms->maxbytes2transmit;
+				ms->eoftx = 0;
+			    } else {
+				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], left);
+				ms->writeidx[ms->outwritebuf] += left + 2;
+				txb += left + 2;
+				ms->bytes2transmit = left;
+				ms->eoftx = 1;
+			    }
+			    bytes = 0;
+#endif
 			} else {
 				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], left);
 				ms->writeidx[ms->outwritebuf]+=left;
 				txb += left;
 				bytes -= left;
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+				ms->bytes2transmit=ZT_CHUNKSIZE;
+#endif
 			}
 			/* Check buffer status */
 			if (ms->writeidx[ms->outwritebuf] >= ms->writen[ms->outwritebuf]) {
@@ -5291,6 +5349,17 @@
 				/* Transmit a flag if this is an HDLC channel */
 				if (ms->flags & ZT_FLAG_HDLC)
 					fasthdlc_tx_frame_nocheck(&ms->txhdlc);
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+				if(ms->flags & ZT_FLAG_BRIDCHAN) { 
+			//	    if (ms->bytes2transmit > 0) {
+					// txb += 2;
+					// ms->bytes2transmit -= 2;
+					bytes=0;
+					ms->eoftx = 1;
+//					printk(KERN_CRIT "zaptel EOF(%d) bytes2transmit %d\n",ms->eoftx,ms->bytes2transmit);
+			//	    }
+				}
+#endif
 #ifdef CONFIG_ZAPATA_NET
 				if (ms->flags & ZT_FLAG_NETDEV)
 					netif_wake_queue(ztchan_to_dev(ms));
@@ -5351,6 +5420,12 @@
 				memset(txb, 0xFF, bytes);
 			}
 			bytes = 0;
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+		} else if(ms->flags & ZT_FLAG_BRIDCHAN) { 
+		    ms->bytes2transmit = 0;
+		    ms->eoftx = 0;
+		    bytes = 0;
+#endif
 		} else {
 			memset(txb, ZT_LIN2X(0, ms), bytes);	/* Lastly we use silence on telephony channels */
 			bytes = 0;
@@ -6169,6 +6244,14 @@
 	int res;
 	int left, x;
 
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)
+	if (ms->flags & ZT_FLAG_BRIDCHAN) {
+		bytes = ms->bytes2receive;
+		if ( bytes < 1) return;
+		printk(KERN_CRIT "bytes2receive %d\n", ms->bytes2receive);
+	}
+#endif
+
 	while(bytes) {
 #if defined(CONFIG_ZAPATA_NET)  || defined(CONFIG_ZAPATA_PPP)
 		skb = NULL;
@@ -6226,6 +6309,19 @@
 						}
 					}
 				}
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+			} else if (ms->flags & ZT_FLAG_BRIDCHAN) {
+			    memcpy(buf + ms->readidx[ms->inreadbuf], rxb, left);
+			    rxb += left;
+			    ms->readidx[ms->inreadbuf] += left;
+			    bytes -= left;
+			    if (ms->eofrx == 1) {
+				eof=1;
+			    }
+//			    printk(KERN_CRIT "receiving %d bytes\n",ms->bytes2receive);
+			    ms->bytes2receive = 0;
+			    ms->eofrx = 0;
+#endif
 			} else {
 				/* Not HDLC */
 				memcpy(buf + ms->readidx[ms->inreadbuf], rxb, left);
diff -burN zaptel-1.4.5.1.orig/zaptel.h zaptel-1.4.5.1/zaptel.h
--- zaptel-1.4.5.1.orig/zaptel.h	2007-12-04 09:47:55.000000000 +0100
+++ zaptel-1.4.5.1/zaptel.h	2007-12-04 10:00:04.000000000 +0100
@@ -1120,6 +1120,13 @@
 	int do_ppp_error;
 	struct sk_buff_head ppp_rq;
 #endif
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+	int bytes2receive;
+	int maxbytes2transmit; /* size of the tx buffer in the card driver */
+	int bytes2transmit;
+	int eofrx;
+	int eoftx;
+#endif
 	spinlock_t lock;
 	char name[40];		/* Name */
 	/* Specified by zaptel */
@@ -1360,6 +1367,10 @@
 #define ZT_FLAG_NOSTDTXRX		(1 << 17)	/* Do NOT do standard transmit and receive on every interrupt */
 #define ZT_FLAG_LOOPED			(1 << 18)	/* Loopback the receive data from the channel to the transmit */
 
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+#define ZT_FLAG_BRIDCHAN		(1 << 17)
+#endif
+
 struct zt_span {
 	spinlock_t lock;
 	void *pvt;			/* Private stuff */
@@ -1463,6 +1474,10 @@
 	int watchcounter;
 	int watchstate;
 #endif	
+#ifdef CONFIG_PROC_FS
+	/* Allow subordinate drivers to print out their own stuff */
+	int (*proc_read)(struct zt_span *span, char *start);
+#endif
 };
 
 struct zt_transcoder_channel {
@@ -1595,6 +1610,9 @@
 /* Notify a change possible change in alarm status */
 void zt_alarm_notify(struct zt_span *span);
 
+/* Notify a change possible change in alarm status, DONT change the zaptel master! */
+extern void zt_alarm_notify_no_master_change(struct zt_span *span);
+
 /* Initialize a tone state */
 void zt_init_tone_state(struct zt_tone_state *ts, struct zt_tone *zt);
 
diff -burN zaptel-1.4.5.1.orig/zconfig.h zaptel-1.4.5.1/zconfig.h
--- zaptel-1.4.5.1.orig/zconfig.h	2007-12-04 09:47:55.000000000 +0100
+++ zaptel-1.4.5.1/zconfig.h	2007-12-04 10:00:04.000000000 +0100
@@ -187,4 +187,10 @@
  */
 /* #define FXSFLASH */
 
+/*
+ * Uncomment the following for BRI D channels
+ *
+ */
+#define CONFIG_ZAPATA_BRI_DCHANS
+
 #endif
diff -burN zaptel-1.4.5.1.orig/ztcfg.c zaptel-1.4.5.1/ztcfg.c
--- zaptel-1.4.5.1.orig/ztcfg.c	2007-12-04 09:47:55.000000000 +0100
+++ zaptel-1.4.5.1/ztcfg.c	2007-12-04 10:39:08.000000000 +0100
@@ -96,6 +96,10 @@
 
 static int stopmode = 0;
 
+static int stopwhich = -1;
+
+static int startwhich = -1;
+
 static int numdynamic = 0;
 
 static char zonestoload[ZT_TONE_ZONE_MAX][10];
@@ -1261,7 +1265,8 @@
 		"  -d [level]        -- Generate debugging output. (Default level is 1.)\n"
 		"  -f                -- Always reconfigure every channel\n"
 		"  -h                -- Generate this help statement\n"
-		"  -s                -- Shutdown spans only\n"
+		"  -s[span]          -- Deactivate/shutdown span [span]. Deactivates all spans if no [span] is given.\n"
+		"  -a[span]          -- Activate/start span [span]. Activates all spans if no [span] is given.\n"
 		"  -t                -- Test mode only, do not apply\n"
 		"  -v                -- Verbose (more -v's means more verbose)\n"
 	,c);
@@ -1274,7 +1279,7 @@
 	char *buf;
 	char *key, *value;
 	int x,found;
-	while((c = getopt(argc, argv, "fthc:vsd::")) != -1) {
+	while((c = getopt(argc, argv, "fthc:vs::a::d::")) != -1) {
 		switch(c) {
 		case 'c':
 			filename=optarg;
@@ -1295,8 +1300,20 @@
 			fo_real = 0;
 			break;
 		case 's':
+			if (optarg) {
+			    stopwhich = atoi(optarg);
+			} else {
+			    stopwhich = -1;
+			}
 			stopmode = 1;
 			break;
+		case 'a':
+			if (optarg) {
+			    startwhich = atoi(optarg);
+			} else {
+			    startwhich = -1;
+			}
+			break;
 		case 'd':
 			if (optarg)
 				debug = atoi(optarg);
@@ -1358,6 +1375,17 @@
 				ioctl(fd, ZT_DYNAMIC_DESTROY, &zds[x]);
 			}
 			if (stopmode) {
+				if (stopwhich > 0) {
+					if ((stopwhich > spans) || (ioctl(fd, ZT_SHUTDOWN, &lc[stopwhich - 1].span))) {
+						fprintf(stderr, "Zaptel shutdown failed: %s\n", strerror(errno));
+						close(fd);
+						exit(1);
+					} else {
+						if (verbose) {
+							printf("Deactivated span %d\n", stopwhich);
+						}
+					}
+				} else {
 				for (x=0;x<spans;x++) {
 					if (ioctl(fd, ZT_SHUTDOWN, &lc[x].span)) {
 						fprintf(stderr, "Zaptel shutdown failed: %s\n", strerror(errno));
@@ -1365,7 +1393,9 @@
 						exit(1);
 					}
 				}
+				}
 			} else {
+				if ( startwhich == -1) {
 				for (x=0;x<spans;x++) {
 					if (ioctl(fd, ZT_SPANCONFIG, lc + x)) {
 						fprintf(stderr, "ZT_SPANCONFIG failed on span %d: %s (%d)\n", lc[x].span, strerror(errno), errno);
@@ -1474,6 +1504,18 @@
 						exit(1);
 					}
 				}
+				}
+				if ( startwhich > 0 ) {
+					if ( (startwhich > spans) || (ioctl(fd, ZT_STARTUP, &lc[startwhich - 1].span))) {
+						fprintf(stderr, "Zaptel startup failed: %s\n", strerror(errno));
+						close(fd);
+						exit(1);
+					} else {
+						if (verbose) {
+							printf("Activated span %d\n", startwhich);
+						}
+					}
+				} else {
 				for (x=0;x<spans;x++) {
 					if (ioctl(fd, ZT_STARTUP, &lc[x].span)) {
 						fprintf(stderr, "Zaptel startup failed: %s\n", strerror(errno));
@@ -1483,6 +1525,7 @@
 				}
 			}
 		}
+		}
 	} else {
 		fprintf(stderr, "\n%d error(s) detected\n\n", errcnt);
 		exit(1);
diff -burN zaptel-1.4.5.1.orig/ztpty.c zaptel-1.4.5.1/ztpty.c
--- zaptel-1.4.5.1.orig/ztpty.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.5.1/ztpty.c	2007-12-04 10:00:04.000000000 +0100
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/time.h>
+#include <sys/signal.h>
+#include <sys/select.h>
+#include <math.h>
+#include "zaptel.h"
+
+#define SIZE 8000
+
+
+
+void doit(int fd, int stdinfd) {
+    fd_set fds;
+    char inbuffer[4096];
+    char outbuffer[4096];
+    int res = 0;
+    int i = 0;
+
+//    fprintf(stderr, "fd %d stdin fd %d\n", fd, stdinfd);
+
+    for (;;) {
+	FD_ZERO(&fds);
+        FD_SET(fd, &fds);
+	FD_SET(stdinfd, &fds);
+        /* Wait for *some* sort of I/O */
+        res = select(stdinfd + 1, &fds, NULL, NULL, NULL);
+        if (res < 0) {
+                fprintf(stderr, "Error in select: %s\n", strerror(errno));
+                return;
+        }
+        if (FD_ISSET(stdinfd, &fds)) {
+            res = read(stdinfd, inbuffer, sizeof(inbuffer));
+	    if (res > 0) {
+//		fprintf(stderr, "read %d bytes from stdin\n", res);
+		if (res > 0) {
+		    for (i=0; i < res ; i++) {
+			if (inbuffer[i] == '\n') {
+			    if ((i > 0) && (inbuffer[i-1] == ' ')) {
+				inbuffer[i-1] = 0x1a;
+			    }
+			    inbuffer[i] = 0xd;
+			}
+		    }
+		res = write(fd, inbuffer, res+2);
+//		res = write(STDOUT_FILENO, inbuffer, res);
+//		fprintf(stderr, "wrote %d bytes to stdout\n", res);
+		}
+	    }
+        }
+        if (FD_ISSET(fd, &fds)) {
+            res = read(fd, outbuffer, sizeof(outbuffer));
+//	    fprintf(stderr, "read %d bytes from fd\n", res);
+	    if (res > 0) {
+		res = write(STDOUT_FILENO, outbuffer, res);
+//		fprintf(stderr, "wrote %d bytes to stdout\n", res);
+	    }
+        }
+    }
+
+
+}
+
+int main(int argc, char *argv[])
+{
+	int fd;
+	int stdinfd;
+	struct zt_params p;
+	struct zt_bufferinfo bi;
+	int blocksize=0;
+	fd = open(argv[1], O_RDWR | O_NONBLOCK);
+	if (fd < 0) {
+		fprintf(stderr, "Unable to open zap interface: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (ioctl(fd, ZT_GET_PARAMS, &p)) {
+		fprintf(stderr, "Unable to get parameters on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	}
+	if ((p.sigtype != ZT_SIG_HDLCRAW) && (p.sigtype != ZT_SIG_HDLCFCS)) {
+		fprintf(stderr, "%s is in %d signalling, not FCS HDLC or RAW HDLC mode\n", argv[1], p.sigtype);
+		exit(1);
+	}
+
+	if (ioctl(fd, ZT_GET_BLOCKSIZE, &blocksize)) {
+		fprintf(stderr, "Unable to get blocksize on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	} else {
+//		fprintf(stderr, "blocksize %d\n", blocksize);
+	}
+	
+	bi.txbufpolicy = ZT_POLICY_IMMEDIATE;
+        bi.rxbufpolicy = ZT_POLICY_IMMEDIATE;
+	bi.numbufs = 16;
+	bi.bufsize = 1024;
+	if (ioctl(fd, ZT_SET_BUFINFO, &bi)) {
+		fprintf(stderr, "Unable to set buffer info on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	}
+
+	stdinfd = open("/dev/stdin", O_RDONLY | O_NONBLOCK);
+
+	
+	doit(fd, stdinfd);
+	close(stdinfd);
+	close(fd);
+	return 0;
+}
--- zaptel-1.4.5.1/ztpty.c~	2007-12-04 11:50:52.000000000 +0100
+++ zaptel-1.4.5.1/ztpty.c	2007-12-04 11:55:32.000000000 +0100
@@ -4,6 +4,7 @@
 #include <errno.h>
 #include <string.h>
 #include <fcntl.h>
+#include <sys/ioctl.h>
 #include <sys/time.h>
 #include <sys/signal.h>
 #include <sys/select.h>
